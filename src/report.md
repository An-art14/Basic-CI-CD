# Part 1. Настройка gitlab-runner

1) Подняли виртуальную машину Ubuntu Server 22.04 LTS.

![s](part_1/virt_machine.png)

2) Запустили скрипт, который выполняет установку репозитория ***gitlab-runner***
  
![s](part_1/repo_gitlab-runner.png)

3) Установили на виртуальную машину ***gitlab-runner***
![s](part_1/install_gitlab-runner.png)

4) Запустили ***gitlab-runner*** и зарегистрировали его для использования в текущем проекте (DO6_CICD).

![s](part_1/gitlab-runner_start.png)

# Part 2. Сборка

1) Написали этап для CI по сборке приложений из проекта C2_SimpleBashUtils:
   - В файле gitlab-ci.yml добавли этап запуска сборки через мейк файл из проекта C2.
   - Файлы, полученные после сборки (артефакты), сохрани в произвольную директорию со сроком хранения 30 дней.


![s](part_2/gitlab-ci.yml.png)

 2) Видим этап сборки в пайплайне (прошел успешно)

![s](part_2/build-job.png)

# Part 3. Тест кодстайла

1)  Написали этап для CI, который запускает скрипт кодстайла (***clang-format***).

![s](part_3/style_job.png)

   - Наблюдаем этап кодстайла (пайплайн «зафейлен» по заданию)

![s](part_3/fail.png)

   - В пайплайне отобразили вывод утилиты ***clang-format*** (пайплан "success")

![s](part_3/success.png)

# Part 4. Интеграционные тесты

1) Написали этап для CI, который запускает твои интеграционные тесты из того же проекта.

   - Запустили этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно.

![s](part_4/test_job.png)

   - Этапы пайплайна

![s](part_4/pipeline.png)

- В пайплайне отобразили вывод, что интеграционные тесты успешно прошли / провалились.

![s](part_4/output.png)

# Part 5. Этап деплоя

1) Подняли вторую виртуальную машину Ubuntu Server 22.04 LTS.

![s](part_5/virt_machine2.png)

2) Написали  этап для CD, который «разворачивает» проект на другой виртуальной машине.
   - Запустили этот этап вручную при условии, что все предыдущие этапы прошли успешно.
   - Добавили этап deploy в файл .gitlab-ci.yaml
   - В файл gitlab-ci.yml добавили этап запуска написанного скрипта.

![s](part_5/deploy-job.png)

3)  Написали bash-скрипт, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию 
***/usr/local/bin*** второй виртуальной машины.

![s](part_5/deploy_sh.png)

4) Задаем пароль командой `sudo passwd gitlab-runner`
5) Добавим пользователя ***gitlab-runner*** в группу ***sudoers*** с помощью команды 
   `sudo usermod -aG sudo gitlab-runner`

![s](part_5/sudo_pas_gr.png)

6) Далее сгенерируем ***ssh*** ключ командой `ssh-keygen`

![s](part_5/ssh-keygen.png)

7) Cкопируем ***ssh*** ключ на вторую машину 

![s](part_5/copy_ssh.png)

8) Проверяем, что ключ скопировался на вторую машину

![s](part_5/keys.jpg)

9) Изменяем права доступа на второй машине к директории ***/usr/local/bin*** с помощью команды 
`sudo chmod -R 777`  Давая права 777, мы предоставлям полный доступ (чтение, запись и выполнение) к этим файлам и директориям для всех пользователей 

![s](part_5/chmod.png)

   - После пуша стадия деплой ждёт запуска вручную

![s](part_5/pipeline.png)

   - Вывод пайплайна:

![s](part_5/success_deploy.png)

   - Файлы ***s21_cat*** и ***s21_grep*** появились в директории **/usr/local/bin** на второй машине:

![s](part_5/s21_cat_grep.png)

# Part 6. Дополнительно. Уведомления

1) Напишем `@botfather` в telegram, чтобы создать бота и получить его токен:

![s](part_6/botFather.png)

2) Напишем `@userinfobot` в telegram, чтобы узнать ***id***

![s](part_6/userinfibot.png)

3) Напишем bash-скрипт ***notify.sh***

![s](part_6/notify.sh.png)

4) Добавили этап запуска скрипта ***notify.sh*** (после каждой стадии) в файл ***.gitlab-ci.yaml***

![s](part_6/gitlab-ci.yaml.png)

5) Переходим снова в чат с ботом `@botfather`, открываем ссылку:

![s](part_6/screen.jpg)

6) Нажимаем `/start`

![s](part_6/start.png)

7) Пушим добавленные файлы в ***GitLab***

8) Бот `@sharkjos_CICD_bot` отправил уведомления, содержащие информацию об успешности прохождения как этапа CI, так и этапа CD.

![s](part_6/CICD_bot.png)


